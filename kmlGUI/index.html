<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KML File Viewer with Granular Controls</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@tmcw/togeojson@4.7.0/dist/togeojson.umd.js"></script>
    <style>
        #map {
            height: 80vh;
        }
        #map-container #map {
            height: 100%;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 antialiased">
    <div id="upload-screen" class="min-h-screen flex items-center justify-center bg-gray-100">
        <div class="bg-white p-8 rounded-2xl shadow-lg border border-gray-200 max-w-md w-full mx-4">
            <h1 class="text-3xl font-bold text-gray-800 mb-2 text-center">KML Viewer</h1>
            <p class="text-gray-600 mb-6 text-center">Upload a KML file to view it on the map</p>
            <div class="text-center">
                <label for="kml-file" class="inline-flex items-center px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors cursor-pointer">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                    </svg>
                    Upload KML File
                </label>
                <input type="file" id="kml-file" accept=".kml" class="hidden"/>
            </div>
        </div>
    </div>
    <div id="map-container" class="hidden fixed inset-0 z-50">
        <button id="close-map" class="absolute top-4 right-4 z-10 bg-white p-2 rounded-full shadow-lg hover:bg-gray-100 transition-colors">
            <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
        </button>
        <div class="absolute top-4 left-4 z-10">
            <button id="upload-data" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg hover:bg-blue-700 transition-colors flex items-center mb-2">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                Upload Data
            </button>
            <div id="parameter-info" class="bg-white bg-opacity-90 rounded-lg shadow-lg p-3 text-sm">
                <div class="font-semibold text-gray-800 mb-2">Survey Information:</div>
                <div id="parameter-display" class="space-y-1 text-gray-700">
                    <!-- Parameters will be populated here -->
                </div>
            </div>
        </div>
        <div id="map" class="w-full h-full">
        </div>
    </div>
    <script>
        const API_KEY = ""; // Set your Google Maps API key here, or leave empty for development
        // Auto-select upload endpoint: use local Flask when running locally, else use the existing server
        var isLocalEnv = location.origin.startsWith('file:') || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        isLocalEnv = false
        const API_UPLOAD_URL = isLocalEnv ? 'http://127.0.0.1:5001/UpdateFromKml' : 'http://api-py.mypropertyqr.in:5001/UpdateFromKml';
        let map;
        let currentLayer = null;
        const LAYER_COLORS = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'];
        let colorIndex = 0;
        var track = []
        const extractedData = {
                    lines: [],
                    texts: []
                };
                
        // Organized geoJSON data by description types
        const organizedGeoJSON = {
            Line1: [], // SUBDIVISON LINE
            Line2: [], // BOUNDARY LINE  
            Line3: [], // BASE LINE
            Text1: [], // DIMENSION
            Text2: [], // STONE NUMBER
            Text3: []  // SUBDIVISION AREA
        };
        
        // Global variable to store processed organized data
        let processedOrganizedData = null;
        
        // Function to get organized data (for external access)
        function getOrganizedData() {
            return processedOrganizedData;
        }
        
        // Function to test with the existing file.kml
        async function loadTestKML() {
            try {
                const response = await fetch('./file.kml');
                const kmlText = await response.text();
                displayKmlOnMap(kmlText, 'file.kml');
                return processedOrganizedData;
            } catch (error) {
                console.error('Error loading test KML:', error);
            }
        }
        
        // Function to upload processed data to server
        async function uploadProcessedData() {
            if (!processedOrganizedData) {
                alert('No data to upload. Please load a KML file first.');
                return;
            }
            
            const uploadButton = document.getElementById('upload-data');
            const originalText = uploadButton.innerHTML;
            
            try {
                // Show loading state
                uploadButton.innerHTML = `
                    <svg class="w-5 h-5 mr-2 animate-spin" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Uploading...
                `;
                uploadButton.disabled = true;
                
                const urlParams = new URLSearchParams(window.location.search);

                const id = urlParams.get('id');
                const memberId = urlParams.get('memberId');
                const district = urlParams.get('district');
                const village = urlParams.get('village');
                const taluk = urlParams.get('taluk');
                const survey_no = urlParams.get('survey_no');

                if (!id || !memberId || !district || !village || !taluk || !survey_no) {
                    alert('Missing required URL parameters. Please ensure id, memberId, district, village, taluk, and survey_no are present in the URL.');
                    uploadButton.innerHTML = originalText;
                    uploadButton.disabled = false;
                    return;
                }

                processedOrganizedData.id = id;
                processedOrganizedData.memberId = memberId;
                processedOrganizedData.district = district;
                processedOrganizedData.village = village;
                processedOrganizedData.taluk = taluk;
                processedOrganizedData.survey_no = survey_no;
                
                const response = await fetch(API_UPLOAD_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(processedOrganizedData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Upload successful:', result);
                    
                    // Show success state
                    uploadButton.innerHTML = `
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                        Success!
                    `;
                    
                    setTimeout(() => {
                        uploadButton.innerHTML = originalText;
                        uploadButton.disabled = false;
                    }, 2000);
                    
                    alert('Data uploaded successfully!');
                } else {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error('Upload error:', error);
                
                // Show error state
                uploadButton.innerHTML = `
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                    Failed
                `;
                
                setTimeout(() => {
                    uploadButton.innerHTML = originalText;
                    uploadButton.disabled = false;
                }, 2000);
                
                alert(`Upload failed: ${error.message}`);
            }
        }
        // Function to organize geoJSON data by description types
        function organizeGeoJSONData(geoJson) {
            // Reset organized data
            organizedGeoJSON.Line1 = [];
            organizedGeoJSON.Line2 = [];
            organizedGeoJSON.Line3 = [];
            organizedGeoJSON.Text1 = [];
            organizedGeoJSON.Text2 = [];
            organizedGeoJSON.Text3 = [];
            
            let featuresArray = [];
            if (geoJson && geoJson.type === 'FeatureCollection' && Array.isArray(geoJson.features)) {
                featuresArray = geoJson.features;
            } else if (geoJson && geoJson.type === 'Feature') {
                featuresArray = [geoJson];
            }
            
            featuresArray.forEach((feature, index) => {
                const props = feature.properties || {};
                const description = props.description || '';
                
                // Organize by description type
                switch(description) {
                    case 'SUBDIVISON LINE':
                        organizedGeoJSON.Line1.push(feature);
                        break;
                    case 'BOUNDARY LINE':
                        organizedGeoJSON.Line2.push(feature);
                        break;
                    case 'BASE LINE':
                        organizedGeoJSON.Line3.push(feature);
                        break;
                    case 'DIMENSION':
                        organizedGeoJSON.Text1.push(feature);
                        break;
                    case 'STONE NUMBER':
                        organizedGeoJSON.Text2.push(feature);
                        break;
                    case 'SUBDIVISION AREA':
                        organizedGeoJSON.Text3.push(feature);
                        break;
                    default:
                        console.log(`Unknown description type: ${description}`);
                }
            });
            
            console.log('Organized GeoJSON Data:', organizedGeoJSON);
            return organizedGeoJSON;
        }
        
        // Helper function to round coordinates to specified decimal places
        // 4 decimal places = ~11m precision, good balance for mapping performance
        function roundCoordinate(coord, decimals = 5) {
            return Math.round(coord * Math.pow(10, decimals)) / Math.pow(10, decimals);
        }
        
        // Helper function to extract only longitude and latitude from coordinates with precision control
        function extractLngLat(coordinates) {
            if (Array.isArray(coordinates)) {
                if (typeof coordinates[0] === 'number') {
                    // Single coordinate: [lng, lat, elevation] -> [lng, lat] with 4 decimal precision (~11m accuracy)
                    return [roundCoordinate(coordinates[0]), roundCoordinate(coordinates[1])];
                } else {
                    // Array of coordinates: [[lng, lat, elevation], ...] -> [[lng, lat], ...] with 4 decimal precision (~11m accuracy)
                    return coordinates.map(coord => [roundCoordinate(coord[0]), roundCoordinate(coord[1])]);
                }
            }
            return coordinates;
        }
        
        // Function to process features by their organized type
        function processOrganizedFeatures(organized) {
            const processedData = {
                Line1: [], // SUBDIVISON LINE
                Line2: [], // BOUNDARY LINE  
                Line3: [], // BASE LINE
                Text1: [], // DIMENSION
                Text2: [], // STONE NUMBER
                Text3: []  // SUBDIVISION AREA
            };
            
            // Process Line1 (SUBDIVISON LINE)
            organized.Line1.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    processedData.Line1.push({
                        coordinates: extractLngLat(feature.geometry.coordinates),
                        color: feature.properties.stroke,
                        type: 'SUBDIVISON LINE'
                    });
                }
            });
            
            // Process Line2 (BOUNDARY LINE)
            organized.Line2.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    processedData.Line2.push({
                        coordinates: extractLngLat(feature.geometry.coordinates),
                        color: feature.properties.stroke,
                        type: 'BOUNDARY LINE'
                    });
                }
            });
            
            // Process Line3 (BASE LINE)
            organized.Line3.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    processedData.Line3.push({
                        coordinates: extractLngLat(feature.geometry.coordinates),
                        color: feature.properties.stroke,
                        type: 'BASE LINE'
                    });
                }
            });
            
            // Process Text1 (DIMENSION)
            organized.Text1.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'Point') {
                    processedData.Text1.push({
                        coordinates: extractLngLat(feature.geometry.coordinates),
                        label: feature.properties.name || '',
                        color: feature.properties.labelColor,
                        type: 'DIMENSION'
                    });
                }
            });
            
            // Process Text2 (STONE NUMBER)
            organized.Text2.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'Point') {
                    processedData.Text2.push({
                        coordinates: extractLngLat(feature.geometry.coordinates),
                        label: feature.properties.name || '',
                        color: feature.properties.labelColor,
                        type: 'STONE NUMBER'
                    });
                }
            });
            
            // Process Text3 (SUBDIVISION AREA)
            organized.Text3.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'Point') {
                    processedData.Text3.push({
                        coordinates: extractLngLat(feature.geometry.coordinates),
                        label: feature.properties.name || '',
                        color: feature.properties.labelColor,
                        type: 'SUBDIVISION AREA'
                    });
                }
            });
            
            return processedData;
        }
        
        function parseKmlColor(colorValue) {
            if (!colorValue) return null;
            if (typeof colorValue === 'string' && colorValue.startsWith('#')) {
                return colorValue;
            }
            if (typeof colorValue === 'number') {
                const hex = colorValue.toString(16).padStart(8, '0');
                const alpha = hex.substring(0, 2);
                const blue = hex.substring(2, 4);
                const green = hex.substring(4, 6);
                const red = hex.substring(6, 8);
                return `#${red}${green}${blue}`;
            }
            // Handle KML color format strings (aabbggrr)
            if (typeof colorValue === 'string') {
                const trimmed = colorValue.trim();
                // If it's exactly 8 hex digits (no #), interpret as KML aabbggrr
                if (/^[0-9a-fA-F]{8}$/.test(trimmed)) {
                    const alpha = trimmed.substring(0, 2);
                    const blue = trimmed.substring(2, 4);
                    const green = trimmed.substring(4, 6);
                    const red = trimmed.substring(6, 8);
                    return `#${red}${green}${blue}`;
                }
                const colorMap = {
                    'red': '#FF0000',
                    'green': '#00FF00',
                    'blue': '#0000FF',
                    'yellow': '#FFFF00',
                    'cyan': '#00FFFF',
                    'magenta': '#FF00FF',
                    'white': '#FFFFFF',
                    'black': '#000000',
                    'gray': '#808080',
                    'grey': '#808080',
                    'orange': '#FFA500',
                    'purple': '#800080',
                    'brown': '#A52A2A',
                    'pink': '#FFC0CB'
                };
                return colorMap[trimmed.toLowerCase()] || trimmed;
            }
            return null;
        }
        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 20, lng: 0 },
                zoom: 3,
                mapTypeId: 'satellite',
                streetViewControl: false,
                mapTypeControl: false
            });
            document.getElementById('kml-file').addEventListener('change', handleFileSelect, false);
            document.getElementById('close-map').addEventListener('click', () => {
                document.getElementById('map-container').classList.add('hidden');
                document.getElementById('upload-screen').classList.remove('hidden');
                clearCurrentLayer();
            });
            document.getElementById('upload-data').addEventListener('click', uploadProcessedData);
            
            // Validate and display URL parameters
            validateAndDisplayParameters();
        }
        
        // Function to validate and display URL parameters
        function validateAndDisplayParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const parameters = {
                id: urlParams.get('id'),
                memberId: urlParams.get('memberId'),
                district: urlParams.get('district'),
                village: urlParams.get('village'),
                taluk: urlParams.get('taluk'),
                survey_no: urlParams.get('survey_no')
            };
            
            // Check if all required parameters are present
            const missingParams = [];
            for (const [key, value] of Object.entries(parameters)) {
                if (!value || value.trim() === '') {
                    missingParams.push(key);
                }
            }
            
            const parameterDisplay = document.getElementById('parameter-display');
            if (parameterDisplay) {
                let displayHTML = '';
                for (const [key, value] of Object.entries(parameters)) {
                    const displayName = key === 'memberId' ? 'Member ID' : 
                                      key === 'survey_no' ? 'Survey No' : 
                                      key.charAt(0).toUpperCase() + key.slice(1);
                    displayHTML += `<div><strong>${displayName}:</strong> ${value || 'Missing'}</div>`;
                }
                parameterDisplay.innerHTML = displayHTML;
            }
            
            // Show warning if parameters are missing
            if (missingParams.length > 0) {
                console.warn('Missing required URL parameters:', missingParams);
                const warningDiv = document.createElement('div');
                warningDiv.className = 'bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-2 mt-2 text-xs';
                warningDiv.innerHTML = `<strong>Warning:</strong> Missing parameters: ${missingParams.join(', ')}`;
                document.getElementById('parameter-info').appendChild(warningDiv);
            }
            
            return missingParams.length === 0;
        }
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate parameters before loading the map
            const isValid = validateAndDisplayParameters();
            if (!isValid) {
                alert('Warning: Some required URL parameters are missing. The upload may fail.');
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                displayKmlOnMap(e.target.result, file.name);
                document.getElementById('upload-screen').classList.add('hidden');
                document.getElementById('map-container').classList.remove('hidden');
            };
            reader.readAsText(file);
            event.target.value = '';
        }
        function clearCurrentLayer() {
            if (currentLayer) {
                currentLayer.features.forEach(item => {
                    if (item.type === 'marker' && item.feature) {
                        item.feature.setMap(null);
                    } else if (item.type === 'dashed-line' && item.feature) {
                        if (Array.isArray(item.feature)) {
                            item.feature.forEach(polyline => polyline.setMap(null));
                        } else {
                            item.feature.setMap(null);
                        }
                    } else if (item.type === 'dashed-polygon' && item.feature) {
                        item.feature.setMap(null);
                    }
                });
                if(currentLayer.dataLayer) {
                    currentLayer.dataLayer.setMap(null);
                }
                currentLayer = null;
            }
        }
        function displayKmlOnMap(kmlText, fileName) {
            clearCurrentLayer();
            try {
                const parser = new DOMParser();
                const kml = parser.parseFromString(kmlText, 'text/xml');
                const geoJson = toGeoJSON.kml(kml);

                console.log(geoJson);                
                
                const organized = organizeGeoJSONData(geoJson);
                processedOrganizedData = processOrganizedFeatures(organized);
                
                // Display summary of organized data
                console.log('=== ORGANIZED GEOJSON SUMMARY ===');
                console.log(`Line1 (SUBDIVISON LINE): ${organized.Line1.length} features`);
                console.log(`Line2 (BOUNDARY LINE): ${organized.Line2.length} features`);
                console.log(`Line3 (BASE LINE): ${organized.Line3.length} features`);
                console.log(`Text1 (DIMENSION): ${organized.Text1.length} features`);
                console.log(`Text2 (STONE NUMBER): ${organized.Text2.length} features`);
                console.log(`Text3 (SUBDIVISION AREA): ${organized.Text3.length} features`);
                console.log('================================');
                console.log('Processed Data (coordinates cleaned):', processedOrganizedData);
                
                // Example of coordinate format:
                if (processedOrganizedData.Line1.length > 0) {
                    console.log('Sample Line coordinates (lng,lat only):', processedOrganizedData.Line1[0].coordinates.slice(0, 2));
                }
                if (processedOrganizedData.Text1.length > 0) {
                    console.log('Sample Point coordinates (lng,lat only):', processedOrganizedData.Text1[0].coordinates);
                }
                
                // Now that data is organized and loaded, proceed with map functions
                
                const dataLayer = new google.maps.Data();
                const features = [];
                const fallbackColor = LAYER_COLORS[colorIndex % LAYER_COLORS.length];
                colorIndex++;
                currentLayer = { dataLayer, features, fileName };
                
                // Now process all organized features
                let featuresArray = [];
                if (geoJson && geoJson.type === 'FeatureCollection' && Array.isArray(geoJson.features)) {
                    featuresArray = geoJson.features;
                } else if (geoJson && geoJson.type === 'Feature') {
                    featuresArray = [geoJson];
                }
                const nonDashedFeatures = [];
                featuresArray.forEach((featureJson, index) => {
                    const featureId = `feature_${Date.now()}_${index}`;
                    featureJson.id = featureId;
                    const props = featureJson.properties || {};
                    const geomType = featureJson.geometry ? featureJson.geometry.type : null;
                    if (!geomType) return;
                    const name = props.name || `${geomType} ${index + 1}`;
                    let itemColor = props.stroke || props.fill || fallbackColor;
                    if (geomType === 'Point') {
                        const rawLabelColor = props['icon-color'] || props.labelcolor || props.textcolor || props.color || props.stroke || props.fill;
                        const labelColor = parseKmlColor(rawLabelColor) || '#000000';
                        itemColor = labelColor;
                        extractedData.texts.push({
                            coordinates: [roundCoordinate(featureJson.geometry.coordinates[0]), roundCoordinate(featureJson.geometry.coordinates[1])],
                            label: name,
                            color: labelColor
                        });
                        const marker = new google.maps.Marker({
                            position: {
                                lat: roundCoordinate(featureJson.geometry.coordinates[1]),
                                lng: roundCoordinate(featureJson.geometry.coordinates[0])
                            },
                            map,
                            label: { 
                                text: name, 
                                color: labelColor, 
                                fontWeight: 'bold', 
                                fontSize: '12px' 
                            },
                            icon: { path: 'M 0,0' }
                        });
                        features.push({ id: featureId, type: 'marker', feature: marker, name, color: itemColor });
                    } else {
                        const rawTextColor = props.textcolor || props.labelcolor || props.color;
                        const textColor = parseKmlColor(rawTextColor) || fallbackColor;
                        const rawStrokeColor = props.stroke || props.color;
                        const strokeColor = parseKmlColor(rawStrokeColor) || fallbackColor;
                        const isDashed = strokeColor === '#414141';
                        if (isDashed) {
                            if (geomType === 'LineString') {
                                const path = featureJson.geometry.coordinates.map(coord => ({
                                    lat: roundCoordinate(coord[1]),
                                    lng: roundCoordinate(coord[0])
                                }));
                                extractedData.lines.push({
                                    coordinates: featureJson.geometry.coordinates.map(coord => [roundCoordinate(coord[0]), roundCoordinate(coord[1])]),
                                    color: strokeColor
                                });
                                const createDashedLine = (path, color, weight, opacity) => {
                                    const dashLength = 10;
                                    const gapLength = 5;
                                    const dashedSegments = [];
                                    for (let i = 0; i < path.length - 1; i++) {
                                        const start = path[i];
                                        const end = path[i + 1];
                                        const distance = google.maps.geometry.spherical.computeDistanceBetween(start, end);
                                        const direction = google.maps.geometry.spherical.computeHeading(start, end);
                                        let currentPos = start;
                                        let isDash = true;
                                        let remainingDistance = distance;
                                        while (remainingDistance > 0) {
                                            const segmentLength = isDash ? dashLength : gapLength;
                                            const actualLength = Math.min(segmentLength, remainingDistance);
                                            const nextPos = google.maps.geometry.spherical.computeOffset(currentPos, actualLength, direction);
                                            if (isDash) {
                                                dashedSegments.push([currentPos, nextPos]);
                                            }
                                            currentPos = nextPos;
                                            remainingDistance -= actualLength;
                                            isDash = !isDash;
                                        }
                                    }
                                    return dashedSegments.map(segment => {
                                        return new google.maps.Polyline({
                                            path: segment,
                                            strokeColor: color,
                                            strokeWeight: weight,
                                            strokeOpacity: opacity,
                                            map: map
                                        });
                                    });
                                };
                                const dashedLines = createDashedLine(path, strokeColor, props['stroke-width'] || 2, props['stroke-opacity'] || 1.0);
                                features.push({ id: featureId, type: 'dashed-line', feature: dashedLines, name, color: textColor });
                            } else if (geomType === 'Polygon') {
                                const paths = featureJson.geometry.coordinates.map(ring => 
                                    ring.map(coord => ({ lat: roundCoordinate(coord[1]), lng: roundCoordinate(coord[0]) }))
                                );
                                extractedData.lines.push({
                                    coordinates: featureJson.geometry.coordinates[0].map(coord => [roundCoordinate(coord[0]), roundCoordinate(coord[1])]),
                                    color: strokeColor
                                });
                                const polygon = new google.maps.Polygon({
                                    paths: paths,
                                    strokeColor: strokeColor,
                                    strokeWeight: props['stroke-width'] || 2,
                                    strokeOpacity: props['stroke-opacity'] || 1.0,
                                    fillColor: parseKmlColor(props.fill || props.color) || fallbackColor,
                                    fillOpacity: props['fill-opacity'] || 0.3,
                                    map: map
                                });
                                features.push({ id: featureId, type: 'dashed-polygon', feature: polygon, name, color: textColor });
                            }
                        } else {
                            if (geomType === 'LineString') {
                                extractedData.lines.push({
                                    coordinates: featureJson.geometry.coordinates.map(coord => [roundCoordinate(coord[0]), roundCoordinate(coord[1])]),
                                    color: strokeColor
                                });
                            } else if (geomType === 'Polygon') {
                                extractedData.lines.push({
                                    coordinates: featureJson.geometry.coordinates[0].map(coord => [roundCoordinate(coord[0]), roundCoordinate(coord[1])]),
                                    color: strokeColor
                                });
                            }
                            nonDashedFeatures.push(featureJson);
                            features.push({ id: featureId, type: 'shape', feature: null, name, color: textColor });
                        }
                    }
                });
                if (nonDashedFeatures.length > 0) {
                    const nonDashedGeoJson = {
                        type: 'FeatureCollection',
                        features: nonDashedFeatures
                    };
                    dataLayer.addGeoJson(nonDashedGeoJson);
                }
                dataLayer.setStyle(feature => {
                    const props = {};
                    feature.forEachProperty((value, key) => { props[key] = value; });
                    const isPoint = feature.getGeometry().getType() === 'Point';
                    const rawStrokeColor = props.stroke || props.color;
                    const rawFillColor = props.fill || props.color;
                    const rawTextColor = props.textcolor || props.labelcolor || props.color;
                    const strokeColor = parseKmlColor(rawStrokeColor) || fallbackColor;
                    const fillColor = parseKmlColor(rawFillColor) || fallbackColor;
                    const textColor = parseKmlColor(rawTextColor) || strokeColor;
                    return {
                        visible: !isPoint,
                        strokeColor: strokeColor,
                        strokeWeight: props['stroke-width'] || 2,
                        strokeOpacity: props['stroke-opacity'] || 1.0,
                        fillColor: fillColor,
                        fillOpacity: props['fill-opacity'] || 0.3,
                        title: props.name || props.title || '',
                    };
                });
                dataLayer.setMap(map);
                zoomToData(dataLayer);
            } catch (error) {
                console.error("Error parsing or displaying KML:", error);
                alert("Could not parse the KML file. Please ensure it is a valid KML file.");
            }
        }
        function zoomToData(dataLayer) {
            const bounds = new google.maps.LatLngBounds();
            dataLayer.forEach(feature => {
                processGeometry(feature.getGeometry(), bounds.extend, bounds);
            });
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds);
            }
        }
        function processGeometry(geometry, callback, thisArg) {
            if (!geometry) return;
            if (geometry instanceof google.maps.LatLng) {
                callback.call(thisArg, geometry);
            } else if (geometry instanceof google.maps.Data.Point) {
                callback.call(thisArg, geometry.get());
            } else {
                geometry.getArray().forEach(g => processGeometry(g, callback, thisArg));
            }
        }
        function loadMapsScript() {
            let scriptUrl = `https://maps.googleapis.com/maps/api/js?callback=initMap&libraries=marker,geometry`;
            if (API_KEY && API_KEY.trim() !== "") {
                scriptUrl += `&key=${API_KEY}`;
            } else {
                // For development/testing without API key - using a demo key
                scriptUrl += `&key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg`;
            }
            const script = document.createElement('script');
            script.src = scriptUrl;
            script.async = true;
            script.defer = true;
            script.onerror = () => {
                document.getElementById('map').innerHTML = `<div class="p-4 text-center text-red-700">Failed to load Google Maps script. Please check your internet connection or API key.</div>`;
            };
            document.head.appendChild(script);
        }
        function makeBodyStructure() {
            duppoints = []
            points = []
            subdivision_list = []
            lines = []
            for(let i = 0; i < extractedData.texts.length; i++) {
                duppoints.push({
                    "key":extractedData.texts[i].label,
                    "latitude":roundCoordinate(extractedData.texts[i].coordinates[1]),
                    "longitude":roundCoordinate(extractedData.texts[i].coordinates[0])
                })
            }
            for(let i = 0; i < extractedData.lines.length; i++) {
                lines.push({
                    "key":extractedData.lines[i].color,
                    "latitude":roundCoordinate(extractedData.lines[i].coordinates[0][1]),
                    "longitude":roundCoordinate(extractedData.lines[i].coordinates[0][0]),
                })
            }
        }
        window.onload = loadMapsScript;

    </script>
</body>
</html>